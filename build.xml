<?xml version="1.0" encoding="UTF-8"?>

<!--
	Federation metadata signing process for the UK federation.
	
	* "ant process" generates the other files from the master file, and
	  signs as appropriate.  Requires the keystore password.
	  
	* "ant push" sends all files to the remote site, and requires
	  the remote site password.
-->
<project default="process">
    
	<!--
		Accessing the remote system.
		
		Multiple remote systems are supported, each with its own ssh-accessable
		location for "push" and its own URL for verification of pushed data.
	-->
    <property name="remote.host.1" value="bodach.ucs.ed.ac.uk"/>
    <property name="remote.url.1" value="http://bodach.ucs.ed.ac.uk:9524"/>
    <property name="remote.host.2" value="sdssmail.edina.ac.uk"/>
    <property name="remote.url.2" value="http://sdssmail.edina.ac.uk:82"/>
	
	<!--
	    For times when only one remote host is in use, pre-select it
	    using the following property setting.  Comment this out to allow choice.
	-->
	<!--
	<property name="remote.host" value="${remote.host.1}"/>
	-->
	
	<!--
	    Common parts of the file layout for the remote systems.
	-->
	<property name="remote.user" value="sdssweb"/>
	<property name="remote.dir.sdss" value="dev/fed"/>
	<property name="remote.dir.uk" value="metadata"/>

	<!--
		Local specialised directories.
	-->
	<property name="build.dir" value="${basedir}/build"/>
	<property name="entities.dir" value="entities"/>
    <property name="mdx.dir" value="${basedir}/mdx"/>
	<property name="xml.dir" value="${basedir}/xml"/>

	<!--
		Location of externally supplied tool bundles.
	-->
	<property name="tools.dir" value="tools"/>
	<property name="tools.ant" value="${tools.dir}/ant"/>
	<property name="tools.mda" value="${tools.dir}/mda"/>
	<property name="tools.mdcheck" value="${tools.dir}/mdcheck"/>
    <property name="tools.mdnorm" value="${tools.dir}/mdnorm"/>
	<property name="tools.metadatatool" value="${tools.dir}/metadatatool"/>
	<property name="tools.xmlsectool" value="${tools.dir}/xmlsectool"/>
	<property name="tools.xalan" value="${tools.dir}/xalan"/>
	
	<!--
		Additional ANT task definitions.
	-->
	<taskdef resource="net/sf/antcontrib/antlib.xml">
		<classpath>
			<pathelement location="${tools.ant}/lib/ant-contrib-1.0b3.jar"/>
		</classpath>
	</taskdef>
	
	<!--
		The first phase in the signing process is to concatenate the
		individual entity fragment files (uk*.xml in the entities directory)
		together and enclose them in an <Entities> element.
		
		The resulting file [1] entities.xml contains *all* entities,
		even deleted ones, and contains some information we don't ultimately
		want to publish.  entities.xml itself is neither stored
		in the repository nor published.
	-->
	<property name="entities.file.dir" value="${xml.dir}"/>
	<property name="entities.file.name" value="entities.xml"/>
	<property name="entities.file" value="${entities.file.dir}/${entities.file.name}"/>

	<!--
		The master file contains the UK federation's KeyAuthority descriptors.
	-->
	<property name="master.file.dir" value="${xml.dir}"/>
	<property name="master.file.name" value="master.xml"/>
	<property name="master.file" value="${master.file.dir}/${master.file.name}"/>
	
	<!--
		The full, unfiltered entities.xml is combined with the UK federation
		trust roots (from master.xml) to produce the "UK federation master file"
		([2] ukfederation-metadata-master.xml).  This drops entities marked as
		deleted.  Although the file by this stage conforms to UK federation
		conventions, it may still contain information not intended for
		publication.
	-->
	<property name="uk.master.file" value="ukfederation-metadata-master.xml"/>
	
	<!--
		The UK federation master file acts as the parent to four separate processing
		"streams":  production, test, export and fallback.  The fifth "wayf" stream
		is derived from the production stream.
		
		Each stream has its own XSLT transform and its own unsigned file, as follows:
	-->
	<property name="md.prod.unsigned"   value="ukfederation-metadata-unsigned.xml"/>
	<property name="md.test.unsigned"   value="ukfederation-test-unsigned.xml"/>
	<property name="md.export.unsigned" value="ukfederation-export-unsigned.xml"/>
	<property name="md.back.unsigned"   value="ukfederation-back-unsigned.xml"/>
	<property name="md.wayf.unsigned"   value="ukfederation-wayf-unsigned.xml"/>
	
	<!--
		Each stream has its own signed file.
	-->
	<property name="md.prod.signed"     value="ukfederation-metadata.xml"/>
	<property name="md.test.signed"     value="ukfederation-test.xml"/>
	<property name="md.export.signed"   value="ukfederation-export.xml"/>
	<property name="md.back.signed"     value="ukfederation-back.xml"/>
	<property name="md.wayf.signed"     value="ukfederation-wayf.xml"/>
	
	<!--
		The process (with indentation implying the creation
		hierarchy) is:
		
		[19]	ukfederation-metadata-unsigned.xml
		[20]		ukfederation-metadata.xml
		[25]		ukfederation-wayf-unsigned.xml
		[26]			ukfederation-wayf.xml
		
		[27]	ukfederation-test-unsigned.xml
		[28]		ukfederation-test.xml
		[29]	ukfederation-export-unsigned.xml
		[30]		ukfederation-export.xml
		[31]    ukfederation-back-unsigned.xml
		[32]        ukfederation-back.xml
		
		The numbers in brackets are duplicated in the script where the file in
		question is created.  Some numbers are missing because some old format
		files are no longer being generated.
	-->

	<!--
		Null device location.
	-->
	<condition property="null.device"
		value="nul:" else="/dev/null">
		<os family="windows"/>
	</condition>

	<!--
		Signing keystore type.
		
		On Windows, we use a hard token accessed through PKCS#11.
		On Mac, we use a Java Keystore.
	-->
	<condition property="keystore.uk.sign.type"
		value="PKCS11" else="JKS">
		<os family="windows"/>
	</condition>

	<!--
		Signing keystore location.
		
		On Windows, because we're using PKCS#11, we use an explicit NONE.
		Otherwise, the keystore lives on the UK_KEYS volume.
	-->
	<condition property="keystore.uk.sign.loc"
		value="NONE" else="/Volumes/UK_KEYS/ukfederation-sign.jks">
		<os family="windows"/>
	</condition>

	<!--
		Signing keystore alias.
	-->
	<property name="keystore.uk.sign.alias" value="ukfederation"/>

	<!--
		Verification keystore.
	-->
	<property name="keystore.uk.vfy.loc" value="${build.dir}/ukfederation-2010.jks"/>
	<property name="keystore.uk.vfy.alias" value="ukfederation"/>
	
	<property name="known.hosts" value="${build.dir}/known_hosts"/>

    <!--
        Java memory requirements.
        
        This is used as the max heap setting for all Java invocations.  This amount will
        be more than some invocations require, but there's no harm in having a higher
        limit for all of them.
    -->
	<property name="java.max.memory" value="768m"/>
	
	<!--
	    Full paths to a couple of temporary file locations.
	-->
    <property name="temp.xml" value="${xml.dir}/temp.xml"/>
    <property name="temp2.xml" value="${xml.dir}/temp2.xml"/>
	
	
	<!--
		*************************************************
		***                                           ***
		***   E N T R Y   P O I N T   T A R G E T S   ***
		***                                           ***
		*************************************************
	-->
	
	<!--
		Standard processing: generate, sign, then verify.
	-->
	<target name="process" depends="get.keystore.pass, generate, sign, verify, stats">
		<echo>Processing complete.</echo>
	</target>
	
	<!--
		After standard processing, push: get password, push files, verify them.
	-->
	<target name="push" depends="select.remote.host, get.remote.pass, push.files, verify.remote.metadata">
		<echo>Data pushed and verified.</echo>
	</target>

	<!--
		*************************************
		***                               ***
		***   M E T A D A T A   P U S H   ***
		***                               ***
		*************************************
	-->

	<!--
	    Select the remote host.
	-->
	<target name="select.remote.host">
		<!--
		    User dialog to select remote host.
		-->
		<input addproperty="remote.host" validargs="${remote.host.1},${remote.host.2}">
			Please select the remote host to use:
		</input>
		
		<!--
		    Set details for host 1 if selected.
		-->
		<condition property="remote.host.1.selected">
			<equals arg1="${remote.host}" arg2="${remote.host.1}"/>
		</condition>
		<condition property="remote.url" value="${remote.url.1}">
			<isset property="remote.host.1.selected"/>
		</condition>

        <!--
            Set details for host 2 if selected.
        -->
		<condition property="remote.host.2.selected">
            <equals arg1="${remote.host}" arg2="${remote.host.2}"/>
        </condition>
        <condition property="remote.url" value="${remote.url.2}">
            <isset property="remote.host.2.selected"/>
        </condition>

		<!--
		    Set derived properties.
		-->
		<property name="remote.loc.sdss" value="${remote.user}@${remote.host}:${remote.dir.sdss}"/>
	    <property name="remote.loc.uk" value="${remote.user}@${remote.host}:${remote.dir.uk}"/>

		<!--
		    Display relevant properties.
		-->
		<echoproperties>
			<propertyset>
				<propertyref name="remote.host"/>
				<propertyref name="remote.url"/>
				<propertyref name="remote.loc.sdss"/>
				<propertyref name="remote.loc.uk"/>
			</propertyset>
		</echoproperties>
	</target>

	<!--
		Acquire the remote password.
	-->
	<target name="get.remote.pass" unless="remote.pass">
		<input addproperty="remote.pass">
			Please enter the password for ${remote.user} on ${remote.host}:
		</input>
	</target>

	<!--
		Push all generated XML files, and entity fragment files, to the remote machine.
	-->
	<target name="push.files" depends="select.remote.host, get.remote.pass">
		<!--
			Push metadata files to the old SDSS federation location.
			
			Nowadays, these are not SDSS federation metadata files but other
			miscellaneous files such as UK federation statistics.
		-->
		<echo>Pushing non-metadata files.</echo>
		<scp failonerror="true" password="${remote.pass}" remoteTodir="${remote.loc.sdss}"
				knownhosts="${known.hosts}">
			<fileset dir="${xml.dir}">
				<include name="members.xml"/>
				<include name="ukfederation-members.xsd"/>
				<include name="ukfederation-stats.html"/>
			</fileset>
		</scp>
		<!--
			Push metadata files for the UK Federation.
		-->
		<echo>Pushing UK Federation metadata files.</echo>
		<scp failonerror="true" password="${remote.pass}" remoteTodir="${remote.loc.uk}"
				knownhosts="${known.hosts}">
			<fileset dir="${xml.dir}">
				<include name="${md.prod.signed}"/>
				<include name="${md.wayf.signed}"/>
				<include name="${md.test.signed}"/>
				<include name="${md.back.signed}"/>
				<include name="${md.export.signed}"/>
			</fileset>
		</scp>
	</target>

	<!--
		Verify a metadata file held on the master distribution site.
	-->
	<macrodef name="VFY.remote">
		<attribute name="i"/>
		<sequential>
			<echo>Verifying @{i}...</echo>
			<delete file="${xml.dir}/temp.xml" quiet="true" verbose="false"/>
			<get src="${remote.url}/@{i}" dest="${xml.dir}/temp.xml"/>
			
			<!--
				Verify using metadatatool.
			-->
			<MDT.VFY.uk i="temp.xml"/>

			<!--
				Verify using xmlsectool.
			-->
			<XMLSECTOOL.VFY.uk i="temp.xml"/>
			
			<!--
				Delete the temporary file.
			-->
			<delete file="${xml.dir}/temp.xml" quiet="true" verbose="false"/>
		</sequential>
	</macrodef>
	
	<!--
		Verify a metadata file held on the master distribution site.
	-->
	<target name="verify.remote.metadata" depends="select.remote.host">
		<echo>Verifying metadata held at ${remote.url}</echo>
		<VFY.remote i="${md.prod.signed}"/>
		<VFY.remote i="${md.wayf.signed}"/>
		<VFY.remote i="${md.test.signed}"/>
		<VFY.remote i="${md.back.signed}"/>
		<VFY.remote i="${md.export.signed}"/>
		<echo>Verification completed.</echo>
	</target>
	
	<!--
		*************************************************
		***                                           ***
		***   M E T A D A T A   G E N E R A T I O N   ***
		***                                           ***
		*************************************************
	-->
	
	<!--
		Generate unsigned metadata.
	-->
	<target name="generate" depends="gen.uk.unsigned">
		<echo>Generated unsigned metadata.</echo>
	</target>
	
	<!--
		gen.entities
		
		Concatenates the (potentially many) entity fragment files together into a single file
		wrapping the entities in an <Entities> element.  This can then be dragged in by the document
		function in XSLT.
	-->
	<target name="gen.entities">
		<echo>Composing entity fragment files.</echo>
		<!-- [1] -->
		<concat destfile="${entities.file}" append="no" force="yes" fixlastline="no">
			<header filtering="no">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&#10;&lt;Entities&gt;&#10;</header>
			<fileset dir="${entities.dir}" includes="uk*.xml"/>
			<footer>&lt;/Entities&gt;&#10;</footer>
			<filterchain>
				<replaceregex pattern="&lt;\?[xX][mM][lL] .*&gt;" />
			</filterchain>
		</concat>
	</target>
	
	<!--
		Unsigned metadata generation for the UK Federation.
	-->

	<target name="gen.uk.master" depends="gen.entities">
		<echo>Generating UK federation master file.</echo>
		<!-- [2] -->
		<XALAN.xmldir x="master_ukfederation.xsl" i="${master.file.name}"
			o="${uk.master.file}" />
		<CHECK.ukreg i="${xml.dir}/${uk.master.file}"/>
	</target>
	
	<target name="test.uk.future" depends="gen.uk.unsigned">
		<echo>Checking against future rulesets.</echo>
        <CHECK.base i="${xml.dir}/${uk.master.file}">
            <arg value="${build.dir}/check_future.xsl"/>
            <arg value="${build.dir}/check_saml2int.xsl"/>
        </CHECK.base>
	</target>
	
    <!--
        Check a metadata document for publishability.  This is applied during all
        UK publication flows prior to any signature step.  It is not applied to
        export flows, for which we desire the closest possible correspondence to
        the registered metadata.
        
        At the moment, this is a single test which is no longer being performed elsewhere
        but should pass by construction.  In the longer term it may make sense to
        expand this to the fullest battery possible, with the exception of those
        tests which are registrar-specific.
        
        Parameter 'i' is the file to be checked; no assumption is made
        about its location so this must contain a full path.
    -->
    <macrodef name="CHECK.publishable">
        <attribute name="i"/>
        <sequential>
            <CHECK.base i="@{i}">
                <arg value="${build.dir}/check_fixups.xsl"/>
            </CHECK.base>
        </sequential>
    </macrodef>

	<target name="gen.uk.unsigned" depends="gen.uk.master">
		<echo>Generating unsigned UK metadata files.</echo>
		
		<!-- [19] -->
		<echo>   Production aggregate...</echo>
		<XALAN
			x="${build.dir}/uk_master_unsigned.xsl"
			i="${xml.dir}/${uk.master.file}"
			o="${temp.xml}"/>
        <echo>      normalising namespaces...</echo>
        <XALAN
            x="${build.dir}/ns_norm_uk.xsl"
            i="${temp.xml}"
            o="${xml.dir}/${md.prod.unsigned}" />
		<MDNORM i="${xml.dir}/${md.prod.unsigned}"/>
        <CHECK.publishable i="${xml.dir}/${md.prod.unsigned}"/>
        <!-- [25] -->
		<echo>      DS variant...</echo>
        <XALAN.xmldir x="master_to_wayf.xsl" i="${md.prod.unsigned}"
            o="${md.wayf.unsigned}"/>
        <CHECK.publishable i="${xml.dir}/${md.wayf.unsigned}"/>
		
		<!-- [27] -->
		<echo>   Test aggregate...</echo>
		<XALAN
			x="${build.dir}/uk_master_test.xsl"
			i="${xml.dir}/${uk.master.file}"
			o="${temp.xml}" />
		<echo>      normalising namespaces...</echo>
		<XALAN
	        x="${build.dir}/ns_norm_uk.xsl"
		    i="${temp.xml}"
		    o="${xml.dir}/${md.test.unsigned}"/>
		<MDNORM i="${xml.dir}/${md.test.unsigned}"/>
        <CHECK.publishable i="${xml.dir}/${md.test.unsigned}"/>
		
		<!-- [29] -->
		<echo>   Export aggregate...</echo>
		<XALAN
			x="${build.dir}/uk_master_export.xsl"
			i="${xml.dir}/${uk.master.file}"
			o="${temp.xml}"/>
        <echo>      normalising namespaces...</echo>
        <XALAN
            x="${build.dir}/ns_norm_uk.xsl"
            i="${temp.xml}"
            o="${xml.dir}/${md.export.unsigned}" />
		<MDNORM i="${xml.dir}/${md.export.unsigned}"/>
		
		<!-- [31] -->
		<echo>   Fallback aggregate...</echo>
        <XALAN
            x="${build.dir}/uk_master_back.xsl"
            i="${xml.dir}/${uk.master.file}"
            o="${temp.xml}"/>
        <echo>      normalising namespaces...</echo>
        <XALAN
            x="${build.dir}/ns_norm_uk.xsl"
            i="${temp.xml}"
            o="${xml.dir}/${md.back.unsigned}" />
        <MDNORM i="${xml.dir}/${md.back.unsigned}"/>
        <CHECK.publishable i="${xml.dir}/${md.back.unsigned}"/>
		
        <echo>Generated UK unsigned metadata.</echo>
	</target>
	

    <!--
        ***********************************************************
        ***                                                     ***
        ***   T E S T   M E T A D A T A   G E N E R A T I O N   ***
        ***                                                     ***
        ***********************************************************
    -->
	
    <property name="test.master.file" value="test-metadata-master.xml"/>
    <property name="test.prod.unsigned" value="test-metadata.xml"/>

	<!--
        Generates a set of test metadata based on the same trust roots
        (plus any local modifications) and a set of designated test
        entities.
	-->
	<target name="gen.test">
		<!--
            Concatenate the entity fragment files named testNNNNNN.xml into
            an entities list.
        -->
        <echo>Composing entity fragment files.</echo>
        <concat destfile="${entities.file}" append="no" force="yes" fixlastline="no">
            <header filtering="no">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&#10;&lt;Entities&gt;&#10;</header>
            <fileset dir="${entities.dir}" includes="test*.xml"/>
            <footer>&lt;/Entities&gt;&#10;</footer>
            <filterchain>
                <replaceregex pattern="&lt;\?[xX][mM][lL] .*&gt;" />
            </filterchain>
        </concat>
		
		<!--
		    Combine the entity list with the trust roots.
		-->
        <echo>Generating test federation master file.</echo>
        <XALAN.xmldir x="master_ukfederation.xsl" i="${master.file.name}"
            o="${test.master.file}" />
        <CHECK.ukreg i="${xml.dir}/${test.master.file}"/>
		
		<!--
            Process through to final form.
        -->
        <XALAN.xmldir x="test_master_unsigned.xsl" i="${test.master.file}"
            o="${test.prod.unsigned}" />
	</target>
    
	<!--
	    ***************************
	    ***                     ***
	    ***   M D A   T O O L   ***
	    ***                     ***
	    ***************************
	-->
	
	<!--
	    Macro to run the mda (metadata aggregator CLI) tool.
	-->
    <macrodef name="MDA">
    	<!-- Spring pipeline configuration file -->
    	<attribute name="config"/>
    	<!-- pipeline bean ID -->
    	<attribute name="pipeline"/>
        <sequential>
            <java classname="net.shibboleth.metadata.cli.SimpleCommandLine"
                fork="true" failonerror="true" maxmemory="${java.max.memory}">
                <classpath>
                    <fileset dir="${tools.mda}/lib">
                        <include name="*.jar"/>
                    </fileset>
                	<fileset dir="${tools.dir}/ukf-mda">
                		<include name="*.jar"/>
                	</fileset>
                	<fileset dir="${tools.dir}/xalan/lib">
                		<include name="sdss-xalan-md-*.jar"/>
                	</fileset>
                    <fileset dir="${tools.dir}/xalan/lib">
                        <include name="ukf-members-*.jar"/>
                    </fileset>
                </classpath>
                <jvmarg value="-Djava.endorsed.dirs=${tools.mda}/lib/endorsed"/>
            	<jvmarg value="-Dlogback.configurationFile=${tools.dir}/ukf-mda/logback.xml"/>
            	<jvmarg value="-Dbasedir=${basedir}"/>
            	<arg value="@{config}"/>
            	<arg value="@{pipeline}"/>
            </java>
        </sequential>
    </macrodef>
    
    <!--
        *********************************
        ***                           ***
        ***   M D N O R M   T O O L   ***
        ***                           ***
        *********************************
    -->
    
	<!--
	    MDNORM
	    
	    Macro to call tool to perform textual normalisation on an XML file
	    containing a metadata aggregate.
        
        Parameter 'i' is the file to be normalised; no assumption is made
        about its location so this must contain a full path.
	-->
    <macrodef name="MDNORM">
        <attribute name="i"/><!-- input file -->
        <sequential>
            <java fork="true" maxmemory="${java.max.memory}" failonerror="true" classname="uk.ac.sdss.mdnorm.Normalise">
                <classpath>
                    <fileset dir="${tools.mdnorm}/lib">
                        <include name="*.jar"/>
                    </fileset>
                </classpath>
                <arg value="@{i}"/>
            </java>
        </sequential>
    </macrodef>

	<!--
		*********************************************
		***                                       ***
		***   M E T A D A T A T O O L   T O O L   ***
		***                                       ***
		*********************************************
	-->
	
	<!--
		Macro to run the metadatatool application with appropriate defaults.
	-->
	<macrodef name="MDT">
		<attribute name="i"/><!-- input file, assumed to be in the XML directory -->
		<attribute name="o"/><!-- output file location -->
		<attribute name="keystore"/><!-- keystore file location -->
		<attribute name="storetype" default="JKS"/><!-- type of keystore to use -->
		<attribute name="alias"/><!-- alias of key to use -->
		<element name="args" optional="yes"/>
		<sequential>
			<java classname="edu.internet2.middleware.shibboleth.utils.MetadataTool"
				fork="true" failonerror="true" maxmemory="${java.max.memory}">
				<classpath>
					<fileset dir="${tools.metadatatool}/lib">
						<include name="**/*.jar"/>
					</fileset>
				</classpath>
				<jvmarg value="-Djava.endorsed.dirs=${tools.metadatatool}/endorsed"/>
				<args/>
				<arg value="--keystore"/>
				<arg value="@{keystore}"/>
				<arg value="--storetype"/>
				<arg value="@{storetype}"/>
				<arg value="--alias"/>
				<arg value="@{alias}"/>
				<arg value="--in"/>
				<arg value="file:${xml.dir}/@{i}"/>
				<arg value="--out"/>
				<arg value="@{o}"/>
			</java>
		</sequential>
	</macrodef>
	
	<macrodef name="MDT.SIGN.uk">
		<attribute name="i"/>
		<attribute name="o"/>
		<sequential>
			<MDT i="@{i}" o="${xml.dir}/@{o}"
				keystore="${keystore.uk.sign.loc}"
				storetype="${keystore.uk.sign.type}"
				alias="${keystore.uk.sign.alias}">
				<args>
					<arg value="--sign"/>
					<arg value="--password"/>
					<arg value="${keystore.pass}"/>
				</args>
			</MDT>
		</sequential>
	</macrodef>
	
	<macrodef name="MDT.VFY.uk">
		<attribute name="i"/>
		<sequential>
			<MDT i="@{i}" o="${null.device}" keystore="${keystore.uk.vfy.loc}" alias="${keystore.uk.vfy.alias}"/>
		</sequential>
	</macrodef>
		
	<!--
		*****************************************
		***                                   ***
		***   X M L S E C T O O L   T O O L   ***
		***                                   ***
		*****************************************
	-->
	
	<macrodef name="XMLSECTOOL">
		<attribute name="i"/><!-- input file, assumed to be in the XML directory -->
		<element name="args" optional="yes"/>
		<sequential>
			<java classname="edu.internet2.middleware.security.XmlSecTool"
				fork="true" failonerror="true" maxmemory="${java.max.memory}">
				<classpath>
					<fileset dir="${tools.xmlsectool}/lib">
						<include name="**/*.jar"/>
					</fileset>
				</classpath>
				<jvmarg value="-Djava.endorsed.dirs=${tools.xmlsectool}/endorsed"/>
				<jvmarg value="-Dedu.internet2.middleware.security.XmlSecTool.home=${tools.xmlsectool}"/>
				<args/>
				<arg value="--validateSchema"/>
				<arg value="--schemaDirectory"/>
				<arg value="${xml.dir}"/>
				<arg value="--inFile"/>
				<arg value="${xml.dir}/@{i}"/>
			</java>
		</sequential>
	</macrodef>
	
	<macrodef name="XMLSECTOOL.SIGN.uk">
		<attribute name="i"/><!-- input file, assumed to be in the XML directory -->
		<attribute name="o"/><!-- output file, assumed to be in the XML directory -->
		<sequential>
			<!-- delete the temporary file to be sure we don't use old data -->
			<delete file="${xml.dir}/temp.xml" quiet="true" verbose="false"/>
			
			<!-- perform signing operation into temporary file -->
			<XMLSECTOOL i="@{i}">
				<args>
					<arg value="--sign"/>
					<arg value="--keystore"/>
					<arg value="${null.device}"/>
					<arg value="--keystoreType"/>
					<arg value="${keystore.uk.sign.type}"/>
					<arg value="--key"/>
					<arg value="${keystore.uk.sign.alias}"/>
					<arg value="--keyPassword"/>
					<arg value="${keystore.pass}"/>
					<arg value="--outFile"/>
					<arg value="${xml.dir}/@{o}"/>
					<arg value="--referenceIdAttributeName"/>
					<arg value="ID"/>
					<!--
					<arg value="- -quiet"/>
					-->
				</args>
			</XMLSECTOOL>
			
			<!-- Force the output file to use Unix line endings -->
			<fixcrlf file="${xml.dir}/@{o}" eol="lf"/>

		</sequential>
	</macrodef>
	
	<macrodef name="XMLSECTOOL.VFY.uk">
		<attribute name="i"/><!-- input file, assumed to be in the XML directory -->
		<sequential>
			<XMLSECTOOL i="@{i}">
				<args>
					<arg value="--verifySignature"/>
					<arg value="--certificate"/>
					<arg value="${build.dir}/ukfederation-2010.pem"/>
					<!--
					<arg value="- -quiet"/>
					-->
				</args>
			</XMLSECTOOL>
		</sequential>
	</macrodef>
	
	<!--
		*******************************
		***                         ***
		***   X A L A N   T O O L   ***
		***                         ***
		*******************************
	-->
	
	<!--
		Macro to run the Xalan XSLT engine, taking files from arbitrary
		locations.
	-->
	<macrodef name="XALAN">
		<attribute name="i"/>
		<attribute name="o"/>
		<attribute name="x"/>
		<sequential>
			<java fork="true" maxmemory="${java.max.memory}" failonerror="true" classname="org.apache.xalan.xslt.Process">
				<classpath>
					<fileset dir="${tools.xalan}/lib">
						<include name="*.jar"/>
					</fileset>
				</classpath>
				<jvmarg value="-Djava.endorsed.dirs=${tools.xalan}/endorsed"/>
				<arg value="-IN"/>
				<arg value="@{i}"/>
				<arg value="-OUT"/>
				<arg value="@{o}"/>
				<arg value="-XSL"/>
				<arg value="@{x}"/>
			</java>
		</sequential>
	</macrodef>

	<!--
		Macro to run the Xalan XSLT engine, taking files from pre-defined
		locations.
	-->
	<macrodef name="XALAN.xmldir">
		<attribute name="i"/>
		<attribute name="o"/>
		<attribute name="x"/>
		<sequential>
			<XALAN i="${xml.dir}/@{i}" o="${xml.dir}/@{o}" x="${build.dir}/@{x}"/>
		</sequential>
	</macrodef>

	<!--
		*******************************************
		***                                     ***
		***   M E T A D A T A   S I G N I N G   ***
		***                                     ***
		*******************************************
	-->
	
	<!--
		Acquire the keystore password.
	-->
	<target name="get.keystore.pass" unless="keystore.pass">
		<input addproperty="keystore.pass">
			Please enter the password for the keystores:
		</input>
	</target>

	<!--
		Select tool to sign UK federation metadata with.
	-->
	<macrodef name="SIGN.uk">
		<attribute name="i"/>
		<attribute name="o"/>
		<sequential>
			<XMLSECTOOL.SIGN.uk i="@{i}" o="@{o}"/>
		</sequential>
	</macrodef>

	<!--
		Sign the various metadata files.
	-->
	<target name="sign">
		<echo>Signing UK metadata.</echo>
		<!-- [20] -->
		<SIGN.uk i="${md.prod.unsigned}" o="${md.prod.signed}"/>

		<echo>Signing UK WAYF metadata.</echo>
		<!-- [26] -->
		<SIGN.uk i="${md.wayf.unsigned}" o="${md.wayf.signed}"/>

		<echo>Signing UK test metadata.</echo>
		<!-- [28] -->
		<SIGN.uk i="${md.test.unsigned}" o="${md.test.signed}"/>

		<echo>Signing UK export metadata.</echo>
		<!-- [30] -->
		<SIGN.uk i="${md.export.unsigned}" o="${md.export.signed}"/>

		<echo>Signing UK fallback metadata.</echo>
		<!-- [32] -->
		<SIGN.uk i="${md.back.unsigned}" o="${md.back.signed}"/>
		
		<echo>Generated signed UK metadata.</echo>
	</target>
	
	<!--
		Select the tool to verify UK federation metadata with.
	-->
	<macrodef name="VFY.uk">
		<attribute name="i"/>
		<sequential>
			<!--
				Verify using metadatatool.
			-->
			<MDT.VFY.uk i="@{i}"/>

			<!--
				Verify using xmlsectool.
			-->
			<XMLSECTOOL.VFY.uk i="@{i}"/>
			
		</sequential>
	</macrodef>
		
	<!--
		Verify the signed metadata files.
	-->
	<target name="verify">
		<echo>Verifying signed UK metadata.</echo>
		<VFY.uk i="${md.prod.signed}"/>

		<echo>Verifying signed UK WAYF metadata.</echo>
		<VFY.uk i="${md.wayf.signed}"/>

		<echo>Verifying signed UK test metadata.</echo>
		<VFY.uk i="${md.test.signed}"/>

		<echo>Verifying signed UK export metadata.</echo>
		<VFY.uk i="${md.export.signed}"/>
		
		<echo>Verifying signed UK fallback metadata.</echo>
		<VFY.uk i="${md.back.signed}"/>

		<echo>Verification completed.</echo>
	</target>
	
	<!--
		*****************************************
		***                                   ***
		***   M E T A D A T A   I M P O R T   ***
		***                                   ***
		*****************************************
	-->
	
	<target name="import.metadata">
		<echo>Importing metadata from ${entities.dir}/import.xml</echo>
		
		<!-- Step 1: perform real processing into temporary file -->
		<XALAN x="${build.dir}/import.xsl"
			i="${entities.dir}/import.xml" o="${temp.xml}"/>
		
		<!-- Step 2: normalise namespaces into result file -->
        <XALAN x="${build.dir}/ns_norm_fragment.xsl"
            i="${temp.xml}" o="${entities.dir}/imported.xml"/>
		
		<echo>Imported metadata to ${entities.dir}/imported.xml</echo>
        <CHECK.std i="${entities.dir}/imported.xml">
            <arg value="${build.dir}/check_imported.xsl"/>
            <arg value="${build.dir}/check_vhosts.xsl"/>
        </CHECK.std>
		<echo>Checked.</echo>
	</target>
	
	<!--
		*****************************************
		***                                   ***
		***   M E T A D A T A   C H E C K S   ***
		***                                   ***
		*****************************************
	-->

	<!--
	    Check a metadata document against a set of conventions.
	    
        Parameter 'i' is the file to be checked; no assumption is made
        about its location so this must contain a full path.
        
	    Additional arguments are normally ruleset file names.
	-->
	<macrodef name="CHECK.base">
        <attribute name="i"/>
        <element name="base.args" implicit="yes"/>
        <sequential>
            <java classname="uk.ac.sdss.mdcheck.MetadataCheck"
                fork="true" failonerror="true" maxmemory="${java.max.memory}">
                <classpath>
                    <fileset dir="${tools.mdcheck}/lib">
                        <include name="**/*.jar"/>
                    </fileset>
                    <fileset dir="${tools.xalan}/lib">
                        <include name="**/*.jar"/>
                    </fileset>
                </classpath>
                <jvmarg value="-Djava.endorsed.dirs=${tools.xalan}/endorsed"/>
                <arg value="@{i}"/>
            	<base.args/>
            </java>
        </sequential>
	</macrodef>
	
    <!--
        Check a metadata document against a single ruleset file.
        
        Parameter 'i' is the file to be checked; no assumption is made
        about its location so this must contain a full path.
        
        Parameter 's' is the checking stylesheet to use; assumed to be
        present in the build.dir.
    -->
	<macrodef name="CHECK.one">
        <attribute name="i"/>
		<attribute name="s"/>
        <sequential>
            <CHECK.base i="@{i}">
                <arg value="${build.dir}/@{s}"/>
            </CHECK.base>
        </sequential>
	</macrodef>

	<macrodef name="CHECK.std">
		<attribute name="i"/>
		<element name="std.args" implicit="yes"/>
		<sequential>
			<CHECK.base i="@{i}">
                <!-- set of checking stylesheets applied in every case -->
                <arg value="${build.dir}/check_adfs.xsl"/>
                <arg value="${build.dir}/check_idpdisc.xsl"/>
                <arg value="${build.dir}/check_init.xsl"/>
                <arg value="${build.dir}/check_mdiop.xsl"/>
                <arg value="${build.dir}/check_mdui.xsl"/>
                <arg value="${build.dir}/check_misc.xsl"/>
                <arg value="${build.dir}/check_namespaces.xsl"/>
                <arg value="${build.dir}/check_shibboleth.xsl"/>
				
				<!-- additional arguments -->
				<std.args/>
			</CHECK.base>
		</sequential>
	</macrodef>
	
	<!--
		Check a metadata document against the full set of conventions used by the
		UK federation's registrar function.
		
		Parameter 'i' is the file to be checked; no assumption is made
		about its location so this must contain a full path.
		
	-->
	<macrodef name="CHECK.ukreg">
		<attribute name="i"/>
		<sequential>
			<CHECK.std i="@{i}">
                <arg value="${build.dir}/check_ukreg.xsl"/>
			</CHECK.std>
		</sequential>
	</macrodef>
	
    <!--
        *********************************************
        ***                                       ***
        ***   M E T A D A T A   E X C H A N G E   ***
        ***                                       ***
        *********************************************
    -->
	
	<!--
	    Aggregator based work is divided into channels, each of
	    which lives in a directory under /mdx/.  Channels are
	    mostly named country_source, but there are exceptions
	    to this rule.  Some of the exceptions may be rationalised
	    in the future.
	    
	    Each channel can have a number of verbs which can be
	    executed.  The convention is that the verb names a
	    configuration file, and that the pipeline to execute
	    is named as channel_pipeline.
	    
	    Note that these conventions, which derive from identifier
	    names in the Spring Expression Language, in combination
	    mean that pipelines may be named in the form
	    country_source_pipeline.
	-->
	
	<!--
	    CHANNEL.do
	    
	    Run a particular flow in the named channel.
	-->
    <macrodef name="CHANNEL.do">
        <attribute name="channel"/><!-- channel name -->
    	<attribute name="verb"/><!-- verb to perform -->
        <sequential>
            <echo>Running @{channel} @{verb} flow.</echo>
            <MDA config="${mdx.dir}/@{channel}/@{verb}.xml"
                pipeline="@{channel}_@{verb}"/>
            <echo>Completed @{channel} @{verb} flow.</echo>
        </sequential>
    </macrodef>
	
	<!--
	    CHANNEL.import
	    
	    Run the import flow from the named channel.
	-->
	<macrodef name="CHANNEL.import">
		<attribute name="channel"/><!-- channel name -->
		<sequential>
			<CHANNEL.do channel="@{channel}" verb="import"/>
		</sequential>
	</macrodef>
	
    <!--
        *******************************************************************
        ***                                                             ***
        ***   M D X :   N O N - P R O D U C T I O N   C H A N N E L S   ***
        ***                                                             ***
        *******************************************************************
    -->
    
    <target name="flow.au_aaf.import">
    	<CHANNEL.import channel="au_aaf"/>
    </target>
    
    <target name="flow.ca_caf.import">
        <CHANNEL.import channel="ca_caf"/>
    </target>
    
	<target name="flow.cz_eduid.import">
		<CHANNEL.import channel="cz_eduid"/>
	</target>

	<target name="flow.ie_edugate.import">
        <CHANNEL.import channel="ie_edugate"/>
    </target>
    
    <target name="flow.edugain.import">
        <CHANNEL.import channel="edugain"/>
    </target>
    
    <target name="flow.edugain.test.import">
    	<CHANNEL.do channel="edugain" verb="testImport"/>
    </target>
    
    <target name="flow.si_arnes.import">
        <CHANNEL.import channel="si_arnes"/>
    </target>
    
	<target name="flow.swamid.import">
        <CHANNEL.import channel="swamid"/>
	</target>
    
    <target name="flow.switch.import">
        <CHANNEL.import channel="switch"/>
    </target>
    
    <target name="flow.uk_eduserv.import">
        <CHANNEL.import channel="uk_eduserv"/>
    </target>
    
    <target name="flow.us_incommon.import">
        <CHANNEL.import channel="us_incommon"/>
    </target>
    
	<!--
	    *************************************************
	    ***                                           ***
	    ***   U K   F E D E R A T I O N   R E D U X   ***
	    ***                                           ***
	    *************************************************
	-->
	
    <target name="flow.uk.collect">
    	<CHANNEL.do channel="uk" verb="collect"/>
    </target>
    
	<target name="flow.uk.pub.production">
        <echo>UK production aggregate flow started.</echo>
        <XALAN
            x="${build.dir}/uk_master_unsigned.xsl"
            i="${mdx.dir}/uk/collected.xml"
            o="${temp.xml}"/>
        <echo>      normalising namespaces...</echo>
        <XALAN
            x="${build.dir}/ns_norm_uk.xsl"
            i="${temp.xml}"
            o="${mdx.dir}/uk/${md.prod.unsigned}" />
        <MDNORM i="${mdx.dir}/uk/${md.prod.unsigned}"/>
        <CHECK.publishable i="${mdx.dir}/uk/${md.prod.unsigned}"/>
        <echo>UK production aggregate flow completed.</echo>
	</target>

	<!--
		*******************************
		***                         ***
		***   M I S C E L L A N Y   ***
		***                         ***
		*******************************
	-->
	
	<!--
		Statistics generation
		
		Note that statistics are generated from the UK federation master file,
		so that the statistics process has access to information that will not
		be included in published metadata.
	-->
	<target name="stats" depends="gen.uk.unsigned">
		<echo>Generating UK Federation statistics</echo>
		<XALAN.xmldir
			i="${uk.master.file}"
			o="ukfederation-stats.html"
			x="statistics.xsl"/>
		<fixcrlf file="${xml.dir}/ukfederation-stats.html" eol="lf"/>
	</target>
	
	<!--
		Check mailing list against current metadata
	-->
	<target name="check.mailing.list" depends="gen.uk.master">
		<echo>Checking mailing list entries.</echo>
		<exec executable="perl" dir="${build.dir}">
			<arg value="${build.dir}/addresses.pl"/>
		</exec>
	</target>
	
	<!--
		Extract TLS locations from the UK federation metadata.
	-->
	<target name="extract.locs" depends="gen.uk.unsigned">
		<echo>Extracting TLS locations</echo>
		<exec executable="perl" dir="${build.dir}"
			output="${build.dir}/locations.txt">
			<arg value="${build.dir}/extract_locs.pl"/>
		</exec>
	</target>
	
	<!--
		Extract authorities
	-->
	<target name="extract.authorities">
		<echo>Extracting key authorities</echo>
		<XALAN.xmldir
			i="master.xml"
			o="authorities.pem"
			x="extract_authorities.xsl"/>
	</target>
	
	<!--
		Check authorities
	-->
	<target name="check.authorities">
		<echo>Checking authority certificates</echo>
		<exec executable="perl" dir="${xml.dir}"
			input="${xml.dir}/authorities.pem">
			<arg value="${build.dir}/check_authorities.pl"/>
		</exec>
	</target>

	<!--
		Extract member list for joining date backfill.
	-->
	<target name="extract.member.dates">
		<echo>Extracting member dates</echo>
		<XALAN.xmldir
			i="members.xml"
			o="member-dates.txt"
			x="extract_member_dates.xsl"/>
	</target>

	<!--
		Utility to fold overlong embedded certificates.
	-->
	<target name="fold.embedded.certs">
		<echo>Folding embedded certificates</echo>
		<for param="file">
			<path>
				<fileset dir="${entities.dir}" includes="uk*.xml"/>
			</path>
			<sequential>
				<exec executable="perl" dir="${entities.dir}">
					<arg value="-i"/>
					<arg value="${build.dir}/fold_cert.pl"/>
					<arg value="@{file}"/>
				</exec>
			</sequential>
		</for>
	</target>
	
	<!--
		Utility to remove the old Eduserv gateway certificate.
	-->
	<!--
	<target name="remove.old.eduserv.cert">
		<echo>Removing old Eduserv gateway certificate</echo>
		<for param="file">
			<path>
				<fileset dir="${entities.dir}" includes="uk*.xml"/>
			</path>
			<sequential>
				<exec executable="perl" dir="${entities.dir}">
					<arg value="-i"/>
					<arg value="${build.dir}/remove_old_eduserv_cert.pl"/>
					<arg value="@{file}"/>
				</exec>
			</sequential>
		</for>
	</target>
	-->
	
	<!--
		Utility to add the second Eduserv gateway certificate.
	-->
	<!--
	<target name="add.second.eduserv.cert">
		<echo>Adding second Eduserv gateway certificate</echo>
		<for param="file">
			<path>
				<fileset dir="${entities.dir}" includes="uk*.xml"/>
			</path>
			<sequential>
				<exec executable="perl" dir="${entities.dir}">
					<arg value="-i"/>
					<arg value="${build.dir}/add_second_eduserv_cert.pl"/>
					<arg value="@{file}"/>
				</exec>
			</sequential>
		</for>
	</target>
	-->
	
	<!--
		Extract embedded certificates
	-->
	<target name="extract.embedded" depends="gen.uk.unsigned">
		<echo>Extracting embedded certificates</echo>
		<XALAN.xmldir
			i="${md.prod.unsigned}"
			o="embedded.pem"
			x="extract_embedded.xsl"/>
	</target>
	
	<!--
		Check embedded certificates.
	-->
	<target name="check.embedded" depends="extract.embedded">
		<echo>Checking embedded certificates</echo>
		<exec executable="perl" dir="${xml.dir}"
			input="${xml.dir}/embedded.pem">
			<arg value="${build.dir}/check_embedded.pl"/>
			<arg value="-q"/>
		</exec>
	</target>
	
	<!--
	   Check for IdPs using the single-port configuration.
	-->
	<target name="check.ports" depends="gen.uk.master">
		<echo>Checking vhost use</echo>
        <CHECK.one i="${xml.dir}/${uk.master.file}" s="check_vhosts.xsl"/>
        <echo>Checked.</echo>
	</target>

</project>